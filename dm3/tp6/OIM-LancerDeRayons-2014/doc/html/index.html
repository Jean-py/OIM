<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>M1 Informatique - OIM - mini raytracer: Page principale</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">M1 Informatique - OIM - mini raytracer
   &#160;<span id="projectnumber">2014-2015</span>
   </div>
   <div id="projectbrief">Interface de programmation pour un raytracer minimal</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&#160;associées</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Tout</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Fichiers</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Fonctions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Définitions de type</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Énumérations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Valeurs énumérées</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Amis</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groupes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">M1 Informatique - OIM - mini raytracer Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>Cette documentation correspond à l'environnement de développement d'un lancer de rayon minimal utilisé pour les travaux pratiques de l'UE "Outils Informatiques pour le Multimédia" en Master 1 informatique de l'université Paul Sabatier, Toulouse.</p>
<p>Après réalisation de ce TP, vous devriez voir la scène par défaut suivante :</p>
<div class="image">
<img src="defaultScene.png" alt="defaultScene.png"/>
</div>
<h1><a class="anchor" id="install_sec"></a>
Installation</h1>
<p>Télécharger l'archive <a href="../raytracing.tgz">raytracing.tgz</a> et la décompresser dans un répertoire spécifique. Après décompression : les répertoires suivants seront générés : </p>
<ul>
<li><code>main</code> : Répertoire principal contenant le source à compléter/ecrire pour le TP (fichier main.c) </li>
<li><code>coreraytracer</code> : Répertoire contenant l'architecture logicielle du lancer de rayons minimal </li>
<li><code>doc</code> : Répertoire contenant cette documentation</li>
</ul>
<p>Le code fourni n'a été testé que sous Linux et mac OS X et nécessite un compilateur C/C++.</p>
<h2><a class="anchor" id="dependances"></a>
Dépendances</h2>
<p>l'exploitation et la réalisation des travaux pratiques en utilisant ce code nécessitent l'installation des outils et de bibliothèque de développement pour gérer le format d'images <a href="http://www.openexr.com/">OpenEXR</a>. Toutes les distributions linux proposent des paquets OpenEXR et les bibliothèques et outils sont aussi disponibles pour mac OS X et Windows. Nous ne détaillerons pas ici l'installation de ces outils et bibliothèques.</p>
<p>Il est recommandé d'installé l'outil <a href="http://qtpfsgui.sourceforge.net/">Luminance HDR</a> permettant de visualiser et de convertir interactivement les images HDR générées par ce lancer de rayons minimal.</p>
<h2><a class="anchor" id="compilation"></a>
Compilation</h2>
<p>Le système de compilation utilisé par ce code est le système <a href="http://www.cmake.org/">cmake</a>. L'ensemble des sources de ce logiciel de lancer de rayon minimal est composé de fichiers headers C++ définissant l'architecture de base et placés dans le répertoire <code>coreraytracer</code> . Le répertoire <code>main</code> contient le programme principal (qui devra être complété pendant les TPs) et un module d'interfaçage en C avec l'architecture de base. Toutefois, afin de simplifier l'utilisation de cet environnement, le compilateur à utiliser doit être un compilateur C++ même si <b>le code à écrire est du code C</b>.</p>
<p>Pour compiler le programme, nous utiliserons la possibilité offerte par cmake de compiler en dehors de l'arborescence des sources. Voici la marche à suivre pour compiler votre programme :</p>
<h3><a class="anchor" id="compilation_premiere"></a>
Première compilation</h3>
<ul>
<li>Créer (la première fois) un répertoire <code>build</code> dans le répertoire d'extraction de l'archive <a href="../raytracing.tgz">raytracing.tgz</a> (au même niveau que les répertoires <code>main</code> et <code>coreraytracer</code>) </li>
<li>Dans un terminal, se positionner dans ce répertoire et taper la commande de génération des makefiles : <b>cmake ..</b> </li>
<li>Compiler le programme par la commande <b>make</b> </li>
</ul>
<h3><a class="anchor" id="compilation_toutes"></a>
Toutes les autres compilations</h3>
<ul>
<li>Compiler le programme par la commande <b>make</b> lancée dans le répertoire <code>build</code> </li>
</ul>
<h2><a class="anchor" id="execution"></a>
Exécution</h2>
<ul>
<li>Executer le programme en tappant la commande <b>./main</b> dans le répertoire <code>bin</code> </li>
<li>Une image ayant pour nom monimage.exr est enregistrée dans le répertoire d'exécution. Pour la visualiser, utiliser le programme exrdisplay qui permet de régler l'exposition de l'image (la façon dont les couleurs haute dynamique dans le fichier .exr sont interprétée pour affichage à l'écran). La même image, transformée au format png par un algorithme de recalage de la dynamique des couleurs est aussi générée dans le même répertoire.</li>
</ul>
<h1><a class="anchor" id="tp6"></a>
Sujet du TP6</h1>
<p>Ce TP se décompose en trois étapes : </p>
<ul>
<li>Calcul d'une image avec éclairage direct uniquement </li>
<li>Ajout des reflexions sépculaires (mirroir) </li>
<li>Ajout de la transparence</li>
</ul>
<h2><a class="anchor" id="partie1"></a>
Programmation du rendu d'une image sans réflexion ni transparence.</h2>
<p>La première partie consiste à coder le corps des trois fonctions réalisant le lancer de rayon : <a class="el" href="a00049.html#ab1d1ac9ba4ad1639618cfd7613fee95f">compute_image()</a>, <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a> et <a class="el" href="a00049.html#a9f1daa433c3bc9891cb1202a4e89080f">compute_direct_lighting()</a>. Ce sont les trois fonctions du fichier <b><a class="el" href="a00049.html">main.cpp</a></b>. Pour vous aider dans votre programmation, vous trouverez une librarie de fonctions disponibles dans le fichier <a class="el" href="a00058.html">raytracing.h</a> et documentées dans le module <a class="el" href="a00069.html">Simple Raytracing API</a></p>
<p>Une fois ces fonctions codées, le programme calculera une image correspondant au rendu d'une scène composée de cinq sphères aux propriétés optiques différentes (plastique, métal, verre, platre) posées sur un plan. Dans cette première version, seul les rayons primaires (rayons lancés depuis la caméra) sont pris en compte. Aucune réflexion ou transparence ne sera calculée dans cette première partie.</p>
<p>Pour commencer, vous allez coder la fonction <a class="el" href="a00049.html#ab1d1ac9ba4ad1639618cfd7613fee95f">compute_image()</a> qui est celle, comme son nom l'indique, qui effectue le calcul d'une image pixel par pixel. L'algorithme de cette fonction a été donné dans le <a href="http://www.irit.fr/~Mathias.Paulin/M1Info/OIM/OIM-Cours5.pdf">cours 5</a>. Nous décrivons ici le principe de cette fonction qui devra être programmée en utilisant les outils fournis par les modules <a class="el" href="a00071.html">Ray management API</a> et <a class="el" href="a00074.html">Image management API</a></p>
<p>Le calcul d'une image de synthèse consiste à calculer une couleur pour tous les pixels d'une image en fonction d'une modélisation d'un capteur virtuel. Ce capteur est ici représenté par une <a class="el" href="a00006.html" title="Viewpoint management. ">Camera</a> qui permet, à partir des coordonnées <b>(x,y)</b> d'un pixel d'une image, de créer le rayon passant par ce pixel. La manière dont est créé ce rayon dépend de la <a class="el" href="a00006.html" title="Viewpoint management. ">Camera</a>. La scène étant crée avec une caméra par défaut de type <b>pinhole</b>, la fonction <a class="el" href="a00071.html#ga8cb8aef586b50a39b449ebb804acee60" title="compute the ray for the given pixel ">camera_ray()</a> devra être utilisée afin de créer le rayon primaire. Ce rayon est ensuite tracé dans la scène (par la fonction <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a> à écrire dans la seconde étape de ce TP) et la couleur calculée à l'aide de ce rayon doit être stockée sur le pixel <b>(x,y)</b>. Voir le module <a class="el" href="a00074.html">Image management API</a> pour réaliser cette action.</p>
<p>Votre fonction devra donc, pour chaque pixel de l'image (créée avec la scène dans la fonction <a class="el" href="a00049.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>), dont on prendra soin de récupérer la résolution, créer le rayon correspondant, le tracer dans la scène et stocker la couleur résultante dans l'image.</p>
<p>A noter : tant que les deux autres fonctions ne sont pas programmée, aucune image ne sera réellement calculée.</p>
<p>Dans un second temps vous allez coder la fonction <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a> qui lance un rayon et retourne une couleur obtenue par la somme de l'éclairage direct (couleur calculée par la fonction <a class="el" href="a00049.html#a9f1daa433c3bc9891cb1202a4e89080f">compute_direct_lighting()</a>) et des couleurs provenant des reflets et transparences éventuels aux points d'intersection. Ces deux dernières informations seront calculées dans la deuxième partie de ce TP. Comme nous nous intéressons ici qu'aux rayons primaires, cette fonction ne sera pas récursive puisque seules les premières intersections avec la scène sont nécessaires pour calculer la couleur de chaque pixel. Cette couleur correspond à l'éclairage direct des points visibles depuis la caméra.</p>
<p>Comme vu dans le <a href="http://www.irit.fr/~Mathias.Paulin/M1Info/OIM/OIM-Cours1.pdf">cours 1</a>, l'espace de couleur utilisé pour le calcul d'une image est l'espace <b>RGB</b>. Cet espace est additif, c'est à dire qu'une couleur complexe peut être obtenue en faisant la somme de couleurs simples. De plus, le phénomène de réflexion de la lumière à la surface d'un objet coloré se modélise par une multiplication entre la couleur de l'objet (son aspect) et la couleur de la lumière incidente. Une couleur est représentée, dans le coeur de notre lancé de rayons par un objet de type <a class="el" href="a00007.html" title="Color management. ">Color</a> avec les opérations décrites dans le module <a class="el" href="a00072.html">Color management API</a>.</p>
<p>Lorsque l'on calcule l'intersection entre un rayon et la scène (fonction <a class="el" href="a00071.html#gaa971dcbc0062c359e8464f84662b0bd4" title="intersect a given ray with the scene. ">intersect_scene()</a> du module <a class="el" href="a00071.html">Ray management API</a>), une structure de type <a class="el" href="a00019.html" title="Intersection point definition. ">Isect</a> est construite contenant les informations sur cette intersection (point, normale, aspect).</p>
<p>Dans cette première partie du TP, la fonction <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a> ne calculant que les rayons primaires, nous devons donc calculer l'intersection entre le rayon et la scène. S'il n'y a pas d'intersection, une couleur blanche (triplet <b>RGB</b> [1, 1, 1], élément neutre de la multiplication des couleurs) devra être retournée. S'il y a une intersection, la couleur retournée sera la couleur résultante de l'éclairage direct du point d'intersection par les sources lumineuses de la scène et calculée par la fonction <a class="el" href="a00049.html#a9f1daa433c3bc9891cb1202a4e89080f">compute_direct_lighting()</a> à écrire ensuite.</p>
<p>Dans un troisième et dernier temps pour cette première partie, nous devons calculer l'éclairage direct en un point de la scène. Ce calcul correspond à la fonction <a class="el" href="a00049.html#a9f1daa433c3bc9891cb1202a4e89080f">compute_direct_lighting()</a>. Le calcul de l'éclairage direct dépend d'une part du point de la scène pour lequel il faut réaliser l'opération (décrit par une structure <a class="el" href="a00019.html" title="Intersection point definition. ">Isect</a>) et d'autre part de la direction de vue de ce point (décrit par une structure de type <a class="el" href="a00027.html" title="Ray definition. ">Ray</a>).</p>
<p>L'éclairage direct en un point depuis une source lumineuse est fonction de la visibilité dans l'espace entre ces deux points. Si la source n'est pas visibles, le point est dans l'ombre et la couleur de la source n'est donc pas ajoutée à la couleur du point d'intersection.</p>
<p>Le rôle de la fonction <a class="el" href="a00049.html#a9f1daa433c3bc9891cb1202a4e89080f">compute_direct_lighting()</a> est de calculer la somme, pour chaque source de lumière de la scène, de l'éclairage élémentaire dû à cette source. Cette somme est calculée en ajoutant à une couleur noire (triplet <b>RGB</b> [0, 0, 0], élément neutre de l'addition des couleurs), la valeur de l'éclairage direct lié à chaque source de la scène. La fonction <a class="el" href="a00049.html#a9f1daa433c3bc9891cb1202a4e89080f">compute_direct_lighting()</a> utilise pour cela les fonctions des modules <a class="el" href="a00070.html">Scene definition API</a> (pour accéder à l'ensemble des sources lumineuses de la scène), <a class="el" href="a00071.html">Ray management API</a> (pour calculer la visibilité entre un point et une source de lumière) et <a class="el" href="a00073.html">Lighting computation API</a> (pour calculer l'éclairage direct).</p>
<h2><a class="anchor" id="partie2"></a>
Programmation du calcul des reflexions.</h2>
<p>Cette seconde partie consiste à ajouter les réflexions spéculaire par une programmation récursive de la fonction <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a>. Afin de déterminer un cas d'arrêt pour les appels récursif, deux solutions sont utilisables. Chaque appel récursif de la fonction <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a> rajoute un niveau de réflexion. Une première possibilité pour arrêter la récursion est de limiter le nombre de réflexion à une valeur arbitraire en fonction de la scène et de la précision voulue dans le calcul de l'image (par exemple 10). Afin de permettre ce cas d'arêt, chaque rayon est étiquetté par sa profondeur, correspondant au nombre de réflexion qu'il a eu dans la scène.</p>
<p>Une deuxième manière de terminer la recursivité repose sur l'importance d'un rayon pour un pixel. Lors d'une réflexion spéculaire, la couleur transportée par un rayon est multipliée par un coefficient de réflexion inférieur à 1 pour des raisons physiques de conservation de l'énergie. Ainsi, après de nombreux rebonds, la couleur d'un rayon est multipliée par un coefficient très faible et n'a plus d'impact sur le pixel. On peut alors terminer la récursivité sans perte de qualité dans l'image. Afin de permettre ce cas d'arrêt, le rayon est étiqueté par son importance.</p>
<p>A partir des fonctions définies dans le module <a class="el" href="a00071.html">Ray management API</a> et permettant d'accéder à ces informations sur le rayon, définir un cas d'arêt de la récursivité et renvoyer si ce cas est vérifié la couleur résultante de l'éclairage direct.</p>
<p>Ensuite, si la récursivité n'est pas terminée, en utilisant les fonctions définies dans le module <a class="el" href="a00073.html">Lighting computation API</a>, calculer la couleur réfléchie. Pour cela, il faut tester si le matériau est réflechissant et, si c'est le cas, calculer le rayon réfléchi et le coefficient de réflexion (une couleur). La couleur calculée en lançant le rayon réfléchi devra alors être multipliée par ce coefficient avant d'être ajoutée à la couleur renvoyée par <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a>.</p>
<h2><a class="anchor" id="partie3"></a>
Programmation du calcul de la transparence.</h2>
<p>De façon très similaire à la réflexion, utiliser les fonctions définies dans le module <a class="el" href="a00073.html">Lighting computation API</a> pour calculer la couleur réfractée. Pour cela, il faut tester si le matériau est transparent et, si c'est le cas, calculer le rayon réfracté et le coefficient de transparence (une couleur). La couleur calculée en lançant le rayon réfracté devra alors être multipliée par ce coefficient avant d'être ajoutée à la couleur renvoyée par <a class="el" href="a00049.html#a0bb032ac4d4d1b49ce014a54feed764a">trace_ray()</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Généré le Lundi Novembre 3 2014 07:46:45 pour M1 Informatique - OIM - mini raytracer par
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
